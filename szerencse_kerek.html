<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Szerencsekerék</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            display: flex;
            gap: 40px;
            max-width: 1400px;
            width: 100%;
            align-items: flex-start;
            justify-content: center;
        }

        .wheel-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .wheel-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #wheelCanvas {
            border-radius: 50%;
            box-shadow: 
                0 0 0 8px #e94560,
                0 0 0 12px #0f3460,
                0 0 40px rgba(233, 69, 96, 0.4),
                0 0 80px rgba(233, 69, 96, 0.2);
            transition: transform 0.3s ease;
        }

        .pointer {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 50px solid #e94560;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4));
            z-index: 10;
        }

        .pointer::after {
            content: '';
            position: absolute;
            top: -48px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: #e94560;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.6);
        }

        .buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn-spin {
            background: linear-gradient(135deg, #e94560, #c23a51);
            color: white;
            box-shadow: 0 8px 25px rgba(233, 69, 96, 0.4);
        }

        .btn-spin:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(233, 69, 96, 0.5);
        }

        .btn-spin:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-reset {
            background: linear-gradient(135deg, #4a5568, #2d3748);
            color: white;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .btn-reset:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
        }

        .names-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            max-height: 600px;
            overflow-y: auto;
            width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .names-panel h2 {
            color: #e94560;
            margin-bottom: 20px;
            font-size: 20px;
            text-align: center;
            border-bottom: 2px solid rgba(233, 69, 96, 0.3);
            padding-bottom: 10px;
        }

        .name-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 10px;
            transition: background 0.2s;
            margin-bottom: 5px;
        }

        .name-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .name-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            cursor: pointer;
            accent-color: #e94560;
        }

        .name-item label {
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            flex: 1;
        }

        .name-item.unchecked label {
            color: #666;
            text-decoration: line-through;
        }

        .result-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .result-overlay.show {
            display: flex;
            opacity: 1;
        }

        .result-content {
            text-align: center;
            transform: scale(0.5);
            transition: transform 0.5s ease;
        }

        .result-overlay.show .result-content {
            transform: scale(1);
        }

        .result-label {
            color: #e94560;
            font-size: 24px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        .result-name {
            color: #fff;
            font-size: 72px;
            font-weight: bold;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.8);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .close-result {
            margin-top: 40px;
            padding: 15px 50px;
            font-size: 16px;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .close-result:hover {
            background: #c23a51;
            transform: scale(1.05);
        }

        .warning {
            background: rgba(233, 69, 96, 0.2);
            border: 2px solid #e94560;
            color: #fff;
            padding: 15px 25px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
            display: none;
        }

        .warning.show {
            display: block;
            animation: shake 0.5s ease;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .active-count {
            color: #aaa;
            font-size: 14px;
            text-align: center;
            margin-top: 15px;
        }

        /* Scrollbar styling */
        .names-panel::-webkit-scrollbar {
            width: 8px;
        }

        .names-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .names-panel::-webkit-scrollbar-thumb {
            background: #e94560;
            border-radius: 10px;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .container {
                flex-direction: column;
                align-items: center;
            }

            .names-panel {
                width: 100%;
                max-width: 400px;
                max-height: 300px;
            }

            #wheelCanvas {
                max-width: 350px;
                max-height: 350px;
            }

            .result-name {
                font-size: 36px;
            }
        }

        @media (max-width: 500px) {
            .btn {
                padding: 12px 25px;
                font-size: 14px;
            }

            .result-name {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="wheel-section">
            <div class="wheel-container">
                <div class="pointer"></div>
                <canvas id="wheelCanvas" width="500" height="500"></canvas>
            </div>
            <div class="buttons">
                <button class="btn btn-spin" id="spinBtn">Pörgetés</button>
                <button class="btn btn-reset" id="resetBtn">Újraindítás</button>
            </div>
            <div class="warning" id="warning">
                Legalább 2 aktív név szükséges a sorsoláshoz!
            </div>
        </div>

        <div class="names-panel">
            <h2>Diákok listája</h2>
            <div id="namesList"></div>
            <div class="active-count" id="activeCount"></div>
        </div>
    </div>

    <div class="result-overlay" id="resultOverlay">
        <div class="result-content">
            <div class="result-label">A kiválasztott személy</div>
            <div class="result-name" id="resultName"></div>
            <button class="close-result" id="closeResult">Bezárás</button>
        </div>
    </div>

    <script>
        // Diákok nevei - könnyen szerkeszthető tömb
        const allNames = [
            "Bancsik Alíz",
            "Czinege Annmária Amadea",
            "Dékány Kornél",
            "Demjén Dorka Alíz",
            "Fekete Noel",
            "Földényi Olivia Euniké",
            "Haluska Simon",
            "Hidvégi Hanna",
            "Horváth Dániel Salamon",
            "Kiss Előd Dániel",
            "Klement Uriel Dániel",
            "Korompay Kornél",
            "Kozma Zsófia",
            "Kófalvi Kornél Csaba",
            "Kunos Abigél",
            "Lakatos Manna",
            "László Péter András",
            "Lesták Krisztián",
            "Lovász Adonika",
            "Lukács Bálint",
            "Mikics Mirkó",
            "Mikó Jázmin Elina",
            "Németh Szulamit Hanna",
            "Nyemcsok Tamás Benjámin",
            "Panyik Zalán Benjámin",
            "Pátkai Joel",
            "Samoila Zita Dominika",
            "Szántai-Kis Áron",
            "Szűcs Péter Dávid",
            "Takács Glória",
            "Tóth Ágota Zsófia",
            "Tusnády Salomé Petra"
        ];

        // Állapot változók
        let activeNames = [...allNames];
        let isSpinning = false;
        let currentRotation = 0;
        let audioContext = null;

        // DOM elemek
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const spinBtn = document.getElementById('spinBtn');
        const resetBtn = document.getElementById('resetBtn');
        const namesList = document.getElementById('namesList');
        const warning = document.getElementById('warning');
        const activeCount = document.getElementById('activeCount');
        const resultOverlay = document.getElementById('resultOverlay');
        const resultName = document.getElementById('resultName');
        const closeResult = document.getElementById('closeResult');

        // Színpaletta a szeletekhez
        const colors = [
            '#e94560', '#0f3460', '#533483', '#1a1a2e',
            '#16213e', '#7b2cbf', '#c23a51', '#3d5a80',
            '#2a9d8f', '#e9c46a', '#f4a261', '#e76f51',
            '#264653', '#023e8a', '#0077b6', '#00b4d8',
            '#8338ec', '#3a86ff', '#ff006e', '#fb5607'
        ];

        // Névlista inicializálása
        function initNamesList() {
            namesList.innerHTML = '';
            allNames.forEach((name, index) => {
                const div = document.createElement('div');
                div.className = 'name-item';
                div.innerHTML = `
                    <input type="checkbox" id="name${index}" checked>
                    <label for="name${index}">${name}</label>
                `;
                namesList.appendChild(div);

                const checkbox = div.querySelector('input');
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        div.classList.remove('unchecked');
                        if (!activeNames.includes(name)) {
                            activeNames.push(name);
                        }
                    } else {
                        div.classList.add('unchecked');
                        activeNames = activeNames.filter(n => n !== name);
                    }
                    updateActiveCount();
                    drawWheel();
                });
            });
            updateActiveCount();
        }

        // Aktív nevek számának frissítése
        function updateActiveCount() {
            activeCount.textContent = `Aktív nevek: ${activeNames.length} / ${allNames.length}`;
        }

        // Kerék rajzolása
        function drawWheel() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 10;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(currentRotation);

            if (activeNames.length === 0) {
                // Üres kerék
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fillStyle = '#333';
                ctx.fill();
                ctx.restore();
                return;
            }

            const sliceAngle = (Math.PI * 2) / activeNames.length;

            activeNames.forEach((name, index) => {
                const startAngle = index * sliceAngle;
                const endAngle = startAngle + sliceAngle;

                // Szelet rajzolása
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = colors[index % colors.length];
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Név írása
                ctx.save();
                ctx.rotate(startAngle + sliceAngle / 2);
                ctx.textAlign = 'right';
                ctx.fillStyle = '#fff';
                
                // Betűméret dinamikus beállítása
                const maxFontSize = 16;
                const minFontSize = 10;
                const fontSize = Math.max(minFontSize, Math.min(maxFontSize, 400 / activeNames.length));
                ctx.font = `bold ${fontSize}px Segoe UI, sans-serif`;
                
                // Név rövidítése ha szükséges
                let displayName = name;
                const maxWidth = radius - 40;
                while (ctx.measureText(displayName).width > maxWidth && displayName.length > 3) {
                    displayName = displayName.slice(0, -4) + '...';
                }
                
                ctx.fillText(displayName, radius - 20, fontSize / 3);
                ctx.restore();
            });

            // Középső kör
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fillStyle = '#e94560';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.restore();
        }

        // Audio Context inicializálása
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Kattogó hang generálása
        function playClickSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800 + Math.random() * 400;
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialDecayTo = 0.01;
            gainNode.gain.setTargetAtTime(0.001, audioContext.currentTime + 0.02, 0.01);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.05);
        }

        // Eredmény hang generálása
        function playResultSound() {
            if (!audioContext) return;
            
            const frequencies = [523.25, 659.25, 783.99, 1046.5];
            
            frequencies.forEach((freq, i) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = freq;
                oscillator.type = 'sine';
                
                const startTime = audioContext.currentTime + i * 0.1;
                gainNode.gain.setValueAtTime(0.2, startTime);
                gainNode.gain.setTargetAtTime(0.001, startTime + 0.2, 0.1);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.4);
            });
        }

        // Kiválasztott név meghatározása a kerék aktuális pozíciója alapján
        function getSelectedName() {
            if (activeNames.length === 0) return null;
            
            const sliceAngle = (Math.PI * 2) / activeNames.length;
            
            // Normalizáljuk a rotációt 0 és 2π közé
            let normalizedRotation = currentRotation % (Math.PI * 2);
            if (normalizedRotation < 0) normalizedRotation += Math.PI * 2;
            
            // A mutató felül van (-π/2 pozícióban, azaz 3π/2 = 270°)
            // A kerék az óramutató járásával megegyezően forog (pozitív irány)
            // Meg kell határoznunk, melyik szelet van a mutató alatt
            const pointerAngle = (3 * Math.PI / 2 - normalizedRotation + Math.PI * 2) % (Math.PI * 2);
            
            const selectedIndex = Math.floor(pointerAngle / sliceAngle) % activeNames.length;
            return activeNames[selectedIndex];
        }

        // Pörgetés animáció
        async function spin() {
            if (isSpinning) return;
            if (activeNames.length < 2) {
                warning.classList.add('show');
                setTimeout(() => warning.classList.remove('show'), 3000);
                return;
            }

            warning.classList.remove('show');
            isSpinning = true;
            spinBtn.disabled = true;

            initAudio();

            // Véletlenszerűen kiválasztott győztes
            const winnerIndex = Math.floor(Math.random() * activeNames.length);
            const winner = activeNames[winnerIndex];

            // Szeletszög
            const sliceAngle = (Math.PI * 2) / activeNames.length;
            
            // A mutató a kerék tetején van (-π/2 = 3π/2 = 270° pozícióban)
            // A szelet közepe: winnerIndex * sliceAngle + sliceAngle / 2
            // Ahhoz, hogy ez a szelet a mutató alá kerüljön, a keréknek annyit kell forognia,
            // hogy a szelet közepe a 3π/2 (270°) pozícióba kerüljön
            const sliceCenter = winnerIndex * sliceAngle + sliceAngle / 2;
            
            // Cél rotáció: a szelet közepének el kell jutnia a 3π/2 pozícióba
            // rotation = 3π/2 - sliceCenter (de pozitív irányban forgatunk, több körrel)
            const baseTargetRotation = (3 * Math.PI / 2 - sliceCenter + Math.PI * 2) % (Math.PI * 2);
            
            // Teljes forgatás: több teljes kör + végső pozíció
            const totalSpins = 6; // Teljes körök száma
            const finalRotation = currentRotation + totalSpins * Math.PI * 2 + 
                ((baseTargetRotation - (currentRotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2));

            let lastSlice = -1;

            // 1. fázis: Gyors indulás és lassulás
            const phase1Duration = 3000;
            const phase1StartTime = performance.now();
            const phase1StartRotation = currentRotation;
            const phase1EndRotation = phase1StartRotation + (finalRotation - phase1StartRotation) * 0.5;

            await new Promise(resolve => {
                function animatePhase1(currentTime) {
                    const elapsed = currentTime - phase1StartTime;
                    const progress = Math.min(elapsed / phase1Duration, 1);
                    
                    // Easing: gyors indulás, lassú befejezés
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    currentRotation = phase1StartRotation + (phase1EndRotation - phase1StartRotation) * eased;
                    drawWheel();

                    // Kattogó hang
                    const currentSlice = Math.floor(Math.abs(currentRotation / sliceAngle)) % activeNames.length;
                    if (currentSlice !== lastSlice) {
                        playClickSound();
                        lastSlice = currentSlice;
                    }

                    if (progress < 1) {
                        requestAnimationFrame(animatePhase1);
                    } else {
                        resolve();
                    }
                }
                requestAnimationFrame(animatePhase1);
            });

            // 2. fázis: Hirtelen újra gyorsulás
            const phase2Duration = 1500;
            const phase2StartTime = performance.now();
            const phase2StartRotation = currentRotation;
            const phase2EndRotation = phase1StartRotation + (finalRotation - phase1StartRotation) * 0.75;

            await new Promise(resolve => {
                function animatePhase2(currentTime) {
                    const elapsed = currentTime - phase2StartTime;
                    const progress = Math.min(elapsed / phase2Duration, 1);
                    
                    // Gyors kezdés
                    const eased = progress < 0.3 
                        ? Math.pow(progress / 0.3, 2) * 0.5
                        : 0.5 + (1 - Math.pow(1 - (progress - 0.3) / 0.7, 2)) * 0.5;
                    
                    currentRotation = phase2StartRotation + (phase2EndRotation - phase2StartRotation) * eased;
                    drawWheel();

                    const currentSlice = Math.floor(Math.abs(currentRotation / sliceAngle)) % activeNames.length;
                    if (currentSlice !== lastSlice) {
                        playClickSound();
                        lastSlice = currentSlice;
                    }

                    if (progress < 1) {
                        requestAnimationFrame(animatePhase2);
                    } else {
                        resolve();
                    }
                }
                requestAnimationFrame(animatePhase2);
            });

            // 3. fázis: Visszafelé pörgetés (túllövés majd vissza)
            const phase3Duration = 2000;
            const phase3StartTime = performance.now();
            const phase3StartRotation = currentRotation;
            const overshoot = sliceAngle * 1.5; // Túllövés
            const phase3EndRotation = finalRotation + overshoot;

            await new Promise(resolve => {
                function animatePhase3(currentTime) {
                    const elapsed = currentTime - phase3StartTime;
                    const progress = Math.min(elapsed / phase3Duration, 1);
                    
                    // Gyors indulás, lassú befejezés
                    const eased = 1 - Math.pow(1 - progress, 4);
                    
                    currentRotation = phase3StartRotation + (phase3EndRotation - phase3StartRotation) * eased;
                    drawWheel();

                    const currentSlice = Math.floor(Math.abs(currentRotation / sliceAngle)) % activeNames.length;
                    if (currentSlice !== lastSlice) {
                        playClickSound();
                        lastSlice = currentSlice;
                    }

                    if (progress < 1) {
                        requestAnimationFrame(animatePhase3);
                    } else {
                        resolve();
                    }
                }
                requestAnimationFrame(animatePhase3);
            });

            // 4. fázis: Visszafelé a végső pozícióra (korrekció)
            const phase4Duration = 1500;
            const phase4StartTime = performance.now();
            const phase4StartRotation = currentRotation;

            await new Promise(resolve => {
                function animatePhase4(currentTime) {
                    const elapsed = currentTime - phase4StartTime;
                    const progress = Math.min(elapsed / phase4Duration, 1);
                    
                    // Nagyon sima lassulás visszafelé
                    const eased = 1 - Math.pow(1 - progress, 5);
                    
                    currentRotation = phase4StartRotation + (finalRotation - phase4StartRotation) * eased;
                    drawWheel();

                    const currentSlice = Math.floor(Math.abs(currentRotation / sliceAngle)) % activeNames.length;
                    if (currentSlice !== lastSlice && progress < 0.8) {
                        playClickSound();
                        lastSlice = currentSlice;
                    }

                    if (progress < 1) {
                        requestAnimationFrame(animatePhase4);
                    } else {
                        resolve();
                    }
                }
                requestAnimationFrame(animatePhase4);
            });

            // Végső rotáció beállítása pontosan
            currentRotation = finalRotation;
            drawWheel();

            // Eredmény megjelenítése - a tényleges kiválasztott név
            const actualWinner = getSelectedName();
            
            playResultSound();
            
            // Zoom effekt
            canvas.style.transform = 'scale(1.1)';
            
            setTimeout(() => {
                resultName.textContent = actualWinner;
                resultOverlay.classList.add('show');
            }, 300);

            isSpinning = false;
            spinBtn.disabled = false;
        }

        // Reset funkció
        function reset() {
            if (isSpinning) return;
            
            currentRotation = 0;
            canvas.style.transform = 'scale(1)';
            resultOverlay.classList.remove('show');
            
            // Minden checkbox visszaállítása
            const checkboxes = namesList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = true;
                cb.parentElement.classList.remove('unchecked');
            });
            
            activeNames = [...allNames];
            updateActiveCount();
            drawWheel();
        }

        // Eredmény overlay bezárása
        function closeResultOverlay() {
            resultOverlay.classList.remove('show');
            canvas.style.transform = 'scale(1)';
        }

        // Event listeners
        spinBtn.addEventListener('click', spin);
        resetBtn.addEventListener('click', reset);
        closeResult.addEventListener('click', closeResultOverlay);
        resultOverlay.addEventListener('click', (e) => {
            if (e.target === resultOverlay) {
                closeResultOverlay();
            }
        });

        // Inicializálás
        initNamesList();
        drawWheel();
    </script>
</body>
</html>
